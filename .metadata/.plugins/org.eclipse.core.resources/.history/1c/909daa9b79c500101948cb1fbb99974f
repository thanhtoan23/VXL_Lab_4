/*
 * scheduler.c
 *
 *  Created on: 18 thg 11, 2025
 *      Author: PC LEGION
 */


#include<scheduler.h>

sTasks SCH_tasks_G[SCH_MAX_TASKS];
uint8_t current_index_task = 0;

//void SCH_Init(void){
//	current_index_task = 0;
//}
//
//void SCH_Add_Task ( void (*pFunction)(), uint32_t DELAY, uint32_t PERIOD ){
//    if (current_index_task < SCH_MAX_TASKS){
//
//        SCH_tasks_G[current_index_task].pTask = pFunction;
//        SCH_tasks_G[current_index_task].Delay = DELAY;
//        SCH_tasks_G[current_index_task].Period = PERIOD;
//        SCH_tasks_G[current_index_task].RunMe = 0;
//        SCH_tasks_G[current_index_task].TaskID = current_index_task;
//
//        current_index_task++;
//    }
//    // else{}
//}
//
//
//void SCH_Update(void)
//{
//    for (int i = 0; i < current_index_task; i++){
//        if (SCH_tasks_G[i].Delay > 0){
//            SCH_tasks_G[i].Delay--;
//        } else {
//            SCH_tasks_G[i].Delay = SCH_tasks_G[i].Period;
//            SCH_tasks_G[i].RunMe += 1;
//        }
//    }
//}
//
//
//void SCH_Dispatch_Tasks(void){
//    for (int i = 0; i < current_index_task; i++){
//        if (SCH_tasks_G[i].RunMe > 0){
//            SCH_tasks_G[i].RunMe--;
//            (*SCH_tasks_G[i].pTask)();
//        }
//    }
//}


//void SCH_Init(void) {
//    current_index_task = 0;
//
//    for (uint8_t i = 0; i < SCH_MAX_TASKS; i++) {
//        SCH_tasks_G[i].pTask = 0;
//        SCH_tasks_G[i].Delay = 0;
//        SCH_tasks_G[i].Period = 0;
//        SCH_tasks_G[i].RunMe = 0;
//        SCH_tasks_G[i].TaskID = i;
//    }
//}
//
//
//uint32_t SCH_Add_Task(void (*pFunction)(), uint32_t DELAY, uint32_t PERIOD) {
//    uint8_t index = 0;
//    while (index < SCH_MAX_TASKS && SCH_tasks_G[index].pTask != 0) {
//        index++;
//    }
//
//    if (index == SCH_MAX_TASKS) {
//        return SCH_MAX_TASKS;
//    }
//
//    SCH_tasks_G[index].pTask = pFunction;
//    SCH_tasks_G[index].Delay = DELAY;
//    SCH_tasks_G[index].Period = PERIOD;
//    SCH_tasks_G[index].RunMe = 0;
//    SCH_tasks_G[index].TaskID = index;
//
//    current_index_task++;
//    return index;
//}
//
//uint8_t SCH_Delete_Task(uint32_t taskID) {
//    if (taskID >= SCH_MAX_TASKS || SCH_tasks_G[taskID].pTask == 0) {
//        return 0;
//    }
//
//    SCH_tasks_G[taskID].pTask = 0;
//    SCH_tasks_G[taskID].Delay = 0;
//    SCH_tasks_G[taskID].Period = 0;
//    SCH_tasks_G[taskID].RunMe = 0;
//
//    current_index_task--;
//    return 1;
//}
//
//
//void SCH_Update(void) {
//    for (uint8_t i = 0; i < SCH_MAX_TASKS; i++) {
//        if (SCH_tasks_G[i].pTask == 0) {
//            continue;
//        }
//
//        if (SCH_tasks_G[i].Delay == 0) {
//            SCH_tasks_G[i].RunMe += 1;
//
//            if (SCH_tasks_G[i].Period > 0) {
//                SCH_tasks_G[i].Delay = SCH_tasks_G[i].Period;
//            }
//        } else {
//            SCH_tasks_G[i].Delay -= 1;
//        }
//    }
//}
//
//void SCH_Dispatch_Tasks(void) {
//    for (uint8_t i = 0; i < SCH_MAX_TASKS; i++) {
//        if (SCH_tasks_G[i].RunMe > 0) {
//            (*SCH_tasks_G[i].pTask)();
//
//            SCH_tasks_G[i].RunMe -= 1;
//
//            if (SCH_tasks_G[i].Period == 0) {
//                SCH_Delete_Task(i);
//            }
//        }
//    }
//}
//


#include "scheduler.h"
#include <stdio.h>

sTask SCH_tasks_G[SCH_MAX_TASKS];

void SCH_Init(void) {
    unsigned char i;
    for (i = 0; i < SCH_MAX_TASKS; i++) {
        SCH_Delete_Task(i);
    }
}

void SCH_Update(void) {
    unsigned char Index;
    for (Index = 0; Index < SCH_MAX_TASKS; Index++) {
        if (SCH_tasks_G[Index].pTask) {
            if (SCH_tasks_G[Index].Delay == 0) {
                SCH_tasks_G[Index].RunMe += 1;
                if (SCH_tasks_G[Index].Period) {
                    SCH_tasks_G[Index].Delay = SCH_tasks_G[Index].Period;
                }
            } else {
                SCH_tasks_G[Index].Delay -= 1;
            }
        }
    }
}

uint32_t SCH_Add_Task(void (* pFunction)(), uint32_t DELAY, uint32_t PERIOD) {
    unsigned char Index = 0;
    while ((SCH_tasks_G[Index].pTask != 0) && (Index < SCH_MAX_TASKS)) {
        Index++;
    }

    if (Index == SCH_MAX_TASKS) {
        return SCH_MAX_TASKS; // Error: task list full
    }

    SCH_tasks_G[Index].pTask = pFunction;
    SCH_tasks_G[Index].Delay = DELAY;
    SCH_tasks_G[Index].Period = PERIOD;
    SCH_tasks_G[Index].RunMe = 0;
    SCH_tasks_G[Index].TaskID = Index;

    return Index;
}

uint8_t SCH_Delete_Task(uint32_t taskID) {
    if (taskID >= SCH_MAX_TASKS || SCH_tasks_G[taskID].pTask == 0) {
        return 1; // Error
    }

    SCH_tasks_G[taskID].pTask = 0;
    SCH_tasks_G[taskID].Delay = 0;
    SCH_tasks_G[taskID].Period = 0;
    SCH_tasks_G[taskID].RunMe = 0;
    SCH_tasks_G[taskID].TaskID = 0;

    return 0; // Success
}

void SCH_Dispatch_Tasks(void) {
    unsigned char Index;
    for (Index = 0; Index < SCH_MAX_TASKS; Index++) {
        if (SCH_tasks_G[Index].RunMe > 0) {
            (*SCH_tasks_G[Index].pTask)(); // Run the task
            SCH_tasks_G[Index].RunMe -= 1;

            if (SCH_tasks_G[Index].Period == 0) {
                SCH_Delete_Task(Index);
            }
        }
    }
}


